<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>afl源码分析 | pwnpwn小菜鸡</title><meta name="author" content="tianmai"><meta name="copyright" content="tianmai"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="afl-gcc.c分析首先看到main函数，里面包含 12345find_as(argv[0]);edit_params(argc, argv);execvp(cc_params[0], (char**)cc_params);  这几个主要函数，下面我们逐个分析 find_as寻找as和afl-as是否存在且可执行 edit_params将参数传给gcc 12pwndbg&gt; p *cc_pa">
<meta property="og:type" content="article">
<meta property="og:title" content="afl源码分析">
<meta property="og:url" content="http://example.com/2023/03/06/afl%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/index.html">
<meta property="og:site_name" content="pwnpwn小菜鸡">
<meta property="og:description" content="afl-gcc.c分析首先看到main函数，里面包含 12345find_as(argv[0]);edit_params(argc, argv);execvp(cc_params[0], (char**)cc_params);  这几个主要函数，下面我们逐个分析 find_as寻找as和afl-as是否存在且可执行 edit_params将参数传给gcc 12pwndbg&gt; p *cc_pa">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg">
<meta property="article:published_time" content="2023-03-06T07:48:28.321Z">
<meta property="article:modified_time" content="2023-03-09T13:51:55.206Z">
<meta property="article:author" content="tianmai">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2023/03/06/afl%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-03-09 21:51:55'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">35</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">1</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div></div></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">pwnpwn小菜鸡</a></span><div id="menus"><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">afl源码分析</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-03-06T07:48:28.321Z" title="发表于 2023-03-06 15:48:28">2023-03-06</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-03-09T13:51:55.206Z" title="更新于 2023-03-09 21:51:55">2023-03-09</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="afl源码分析"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="afl-gcc-c分析"><a href="#afl-gcc-c分析" class="headerlink" title="afl-gcc.c分析"></a>afl-gcc.c分析</h2><p>首先看到main函数，里面包含</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">find_as(argv[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">edit_params(argc, argv);</span><br><span class="line"></span><br><span class="line">execvp(cc_params[<span class="number">0</span>], (<span class="keyword">char</span>**)cc_params);</span><br></pre></td></tr></table></figure>

<p>这几个主要函数，下面我们逐个分析</p>
<h3 id="find-as"><a href="#find-as" class="headerlink" title="find_as"></a>find_as</h3><p>寻找as和afl-as是否存在且可执行</p>
<h3 id="edit-params"><a href="#edit-params" class="headerlink" title="edit_params"></a>edit_params</h3><p>将参数传给gcc</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p *cc_params@20</span><br><span class="line"><span class="variable">$2</span> = &#123;0x55f648b97eec <span class="string">&quot;gcc&quot;</span>, 0x7ffff984528d <span class="string">&quot;-o&quot;</span>, 0x7ffff9845290 <span class="string">&quot;exp&quot;</span>, 0x7ffff9845294 <span class="string">&quot;exp.c&quot;</span>, 0x55f648b97fa3 <span class="string">&quot;-B&quot;</span>, 0x55f64a040268 <span class="string">&quot;/home/tianmai/afl&quot;</span>, 0x55f648b9805c <span class="string">&quot;-g&quot;</span>, 0x55f648b9805f <span class="string">&quot;-O3&quot;</span>, 0x55f648b98063 <span class="string">&quot;-funroll-loops&quot;</span>, 0x55f648b98072 <span class="string">&quot;-D__AFL_COMPILER=1&quot;</span>, 0x55f648b97e50 <span class="string">&quot;-DFUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION=1&quot;</span>, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/image-20230306162639869.png" alt="avatar"></p>
<h3 id="execvp"><a href="#execvp" class="headerlink" title="execvp"></a>execvp</h3><p>执行被包装的gcc</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>afl-gcc是gcc的一个包装，给gcc设置参数并运行它。</p>
<h2 id="afl-fuzz-c"><a href="#afl-fuzz-c" class="headerlink" title="afl-fuzz.c"></a>afl-fuzz.c</h2><p>首先看到main函数</p>
<h3 id="while-opt-getopt-argc-argv-“-i-o-f-m-t-T-dnCB-S-M-x-Q”-gt-0"><a href="#while-opt-getopt-argc-argv-“-i-o-f-m-t-T-dnCB-S-M-x-Q”-gt-0" class="headerlink" title="while ((opt = getopt(argc, argv, “+i:o:f:m:t:T:dnCB:S:M:x:Q”)) &gt; 0)"></a>while ((opt = getopt(argc, argv, “+i:o:f:m:t:T:dnCB:S:M:x:Q”)) &gt; 0)</h3><p>这个循环获取各种环境的设置，选项参数等等</p>
<p>各种模式 参数选项</p>
<h3 id="usage-argv-0"><a href="#usage-argv-0" class="headerlink" title="usage(argv[0])"></a>usage(argv[0])</h3><p>显示用法提示</p>
<h3 id="setup-signal-handlers"><a href="#setup-signal-handlers" class="headerlink" title="setup_signal_handlers();"></a>setup_signal_handlers();</h3><p>设置信号处理程序</p>
<h3 id="check-asan-opts"><a href="#check-asan-opts" class="headerlink" title="check_asan_opts();"></a>check_asan_opts();</h3><p>检查ASAN选项</p>
<h3 id="fix-up-sync"><a href="#fix-up-sync" class="headerlink" title="fix_up_sync"></a>fix_up_sync</h3><p>使用-S时验证并修复out_dir和sync_dir。</p>
<h3 id="一堆检查等"><a href="#一堆检查等" class="headerlink" title="一堆检查等"></a>一堆检查等</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(in_dir, out_dir))<span class="comment">//检查输入输出路径是否一致</span></span><br><span class="line">    FATAL(<span class="string">&quot;Input and output directories can&#x27;t be the same&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (dumb_mode) &#123;<span class="comment">//检查是否为dumb_mode模式，以及crash_mode和qemu_mode是否联动设置了</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (crash_mode) FATAL(<span class="string">&quot;-C and -n are mutually exclusive&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (qemu_mode)  FATAL(<span class="string">&quot;-Q and -n are mutually exclusive&quot;</span>);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//一大串设置参数，获取命令行等内容。</span></span><br><span class="line">  <span class="keyword">if</span> (getenv(<span class="string">&quot;AFL_NO_FORKSRV&quot;</span>))    no_forkserver    = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (getenv(<span class="string">&quot;AFL_NO_CPU_RED&quot;</span>))    no_cpu_meter_red = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (getenv(<span class="string">&quot;AFL_NO_ARITH&quot;</span>))      no_arith         = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (getenv(<span class="string">&quot;AFL_SHUFFLE_QUEUE&quot;</span>)) shuffle_queue    = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (getenv(<span class="string">&quot;AFL_FAST_CAL&quot;</span>))      fast_cal         = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (getenv(<span class="string">&quot;AFL_HANG_TMOUT&quot;</span>)) &#123;</span><br><span class="line">    hang_tmout = atoi(getenv(<span class="string">&quot;AFL_HANG_TMOUT&quot;</span>));</span><br><span class="line">    <span class="keyword">if</span> (!hang_tmout) FATAL(<span class="string">&quot;Invalid value of AFL_HANG_TMOUT&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (dumb_mode == <span class="number">2</span> &amp;&amp; no_forkserver)</span><br><span class="line">    FATAL(<span class="string">&quot;AFL_DUMB_FORKSRV and AFL_NO_FORKSRV are mutually exclusive&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (getenv(<span class="string">&quot;AFL_PRELOAD&quot;</span>)) &#123;</span><br><span class="line">    setenv(<span class="string">&quot;LD_PRELOAD&quot;</span>, getenv(<span class="string">&quot;AFL_PRELOAD&quot;</span>), <span class="number">1</span>);</span><br><span class="line">    setenv(<span class="string">&quot;DYLD_INSERT_LIBRARIES&quot;</span>, getenv(<span class="string">&quot;AFL_PRELOAD&quot;</span>), <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (getenv(<span class="string">&quot;AFL_LD_PRELOAD&quot;</span>))</span><br><span class="line">    FATAL(<span class="string">&quot;Use AFL_PRELOAD instead of AFL_LD_PRELOAD&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="save-cmdline-argc-argv"><a href="#save-cmdline-argc-argv" class="headerlink" title="save_cmdline(argc, argv);"></a>save_cmdline(argc, argv);</h3><p>复制当前命令行</p>
<h3 id="fix-up-banner-argv-optind"><a href="#fix-up-banner-argv-optind" class="headerlink" title="fix_up_banner(argv[optind]);"></a>fix_up_banner(argv[optind]);</h3><p>修整并创建run时的banner</p>
<h3 id="check-if-tty"><a href="#check-if-tty" class="headerlink" title="check_if_tty();"></a>check_if_tty();</h3><p>检查是否在TTy终端上面运行。影响not_on_tty。</p>
<h3 id="cpu检查"><a href="#cpu检查" class="headerlink" title="cpu检查"></a>cpu检查</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  get_core_count();<span class="comment">//获取核心数量</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_AFFINITY</span></span><br><span class="line">  bind_to_free_cpu();<span class="comment">//构建绑定到特定核心的进程列表</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* HAVE_AFFINITY */</span></span></span><br><span class="line"></span><br><span class="line">  check_crash_handling();<span class="comment">//确保核心转储不会进入程序</span></span><br><span class="line">  check_cpu_governor();<span class="comment">//检查CPU管理者</span></span><br></pre></td></tr></table></figure>

<h3 id="setup-post"><a href="#setup-post" class="headerlink" title="setup_post();"></a>setup_post();</h3><p>加载后处理器，如果可用的话</p>
<h3 id="setup-shm"><a href="#setup-shm" class="headerlink" title="setup_shm();"></a>setup_shm();</h3><p>设置共享内存块，trace_bits参数就是在这里设置并初始化置零的。</p>
<h3 id="init-count-class16"><a href="#init-count-class16" class="headerlink" title="init_count_class16();"></a>init_count_class16();</h3><p>初始化count_class_lookup16数组,该数组的作用是帮助快速归类统计路径覆盖的数量</p>
<h3 id="setup-dirs-fds"><a href="#setup-dirs-fds" class="headerlink" title="setup_dirs_fds();"></a>setup_dirs_fds();</h3><p>创建所有的输出目录，打开部分全局的文件句柄。创建输出目录queue、crashes、hangs等，打开文件句柄dev_null_fd、dev_urandom_fd以及plot_file等。</p>
<h3 id="read-testcases"><a href="#read-testcases" class="headerlink" title="read_testcases();"></a>read_testcases();</h3><p>逐个读取种子目录下的输入文件列表，并调用add_to_queue函数将相关信息（文件名称、大小等）存入到全局的种子队列queue当中，作为后续模糊测试的种子来源。单个种子信息保存在结构体queue_entry当中，形成单链表。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!access(dfn, F_OK)) passed_det = <span class="number">1</span>;</span><br><span class="line">ck_free(dfn);</span><br><span class="line"></span><br><span class="line">add_to_queue(fn, st.st_size, passed_det);</span><br></pre></td></tr></table></figure>

<p>检查这个种子是否有贡献（比如是否产生了新路径，运行的时间长短来判断），pass_det这一项就置为1表示循环fuzz的时候将跳过该种子。</p>
<h3 id="add-to-queue-fn-st-st-size-passed-det"><a href="#add-to-queue-fn-st-st-size-passed-det" class="headerlink" title="add_to_queue(fn, st.st_size, passed_det);"></a>add_to_queue(fn, st.st_size, passed_det);</h3><p>将新的测试用例插入队列，并初始化fname文件名称，增加cur_depth深度++ queued_paths测试用例数量++，pending_not_fuzzed没被fuzzed测试用例数量++，更新last_path_time = get_cur_time()。</p>
<h3 id="load-auto"><a href="#load-auto" class="headerlink" title="load_auto();"></a>load_auto();</h3><p>加载自动生成的附加组件</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (len &gt;= MIN_AUTO_EXTRA &amp;&amp; len &lt;= MAX_AUTO_EXTRA)</span><br><span class="line">      maybe_add_auto(tmp, len);<span class="comment">/*该函数会将传入的token添加到数组中，如果数组还有空间则，添加进来。没有的话那就在数组的下半部分随机删除一个token，然后将新的添加进来。</span></span><br><span class="line"><span class="comment">数组最大MAX_AUTO_EXTRAS 50x10=500个。影响以下队列extra[]结构体变量，a_extras_cnt 当前token总数量++（添加成功的话）。*/</span></span><br></pre></td></tr></table></figure>

<h3 id="pivot-inputs"><a href="#pivot-inputs" class="headerlink" title="pivot_inputs();"></a>pivot_inputs();</h3><p>根据相应的种子文件路径在输出目录下创建链接或拷贝至该目录下，形成orignal文件，文件命名的规则是%s/queue/id:%06u,orig:%s”, out_dir, id, use_name，并更新至对应的种子信息结构体queue_entry中。</p>
<p>使用函数link_or_copy重新命名并且拷贝；使用函数mark_as_det_done为已经经过确定性变异（deterministic）阶段的testcase文件放入deterministic_done文件夹。这样经过deterministic的testcase就不用浪费时间进行重复。</p>
<h3 id="load-extras"><a href="#load-extras" class="headerlink" title="load_extras"></a>load_extras</h3><p>如果指定了-x参数（字典模式），加载对应的字典到全局变量extras当中，用于后续字典模式的变异当中。</p>
<h3 id="find-timeout"><a href="#find-timeout" class="headerlink" title="find_timeout"></a>find_timeout</h3><p>如果有-t的设置了自己的超时，那么会触发这个函数。</p>
<h3 id="detect-file-args"><a href="#detect-file-args" class="headerlink" title="detect_file_args"></a>detect_file_args</h3><p>检测输入的命令行中是否包含@@参数，如果包含的话需要将@@替换成目录文件”%s/.cur_input”, out_dir，使得模糊测试目标程序的命令完整；同时将目录文件”%s/.cur_input”路径保存在out_file当中，后续变异的内容保存在该文件路径中，用于运行测试目标文件。</p>
<h3 id="setup-stdio-file"><a href="#setup-stdio-file" class="headerlink" title="setup_stdio_file"></a>setup_stdio_file</h3><p>如果目标程序的输入不是来源于文件而是来源于标准输入的话，则将目录文件”%s/.cur_input”文件打开保存在out_fd文件句柄中，后续将标准输入重定向到该文件中；结合detect_file_args函数实现了将变异的内容保存在”%s/.cur_input”文件中，运行目标测试文件并进行模糊测试。</p>
<h3 id="check-binary-argv-optind"><a href="#check-binary-argv-optind" class="headerlink" title="check_binary(argv[optind]);"></a>check_binary(argv[optind]);</h3><p>搜索路径，找到目标二进制文件，检查文件是否存在，是否为shell脚本，同时检查ELF头以及程序是否被插桩。</p>
<h3 id="检查"><a href="#检查" class="headerlink" title="检查"></a>检查</h3><p>用start_time=get_cur_time() 获取开始时间；</p>
<p>检查是不是QEMU_MODE</p>
<h3 id="★开始第一遍fuzz-——-perform-dry-run"><a href="#★开始第一遍fuzz-——-perform-dry-run" class="headerlink" title="★开始第一遍fuzz  —— perform_dry_run"></a>★开始第一遍fuzz  —— perform_dry_run</h3><p>执行input文件夹下的预先准备的所有testcase（perform_dry_run），生成初始化的queue和bitmap。这只对初始输入执行一次，所以叫：dry run。 </p>
<p>a. 第一个是个while循环，遍历之前生成的input_queue 也就是queue链表。该while(q) loop 的前面，准备工作：从队列中取出q-&gt;fname 读取该文件q-&gt;len 大小到use_mem 中，关闭fd</p>
<p>b. 接着调用calibrate_case函数对该case进行校准。该函数内调用方式res = calibrate_case(argv, q, use_mem, 0, 1);</p>
<p>c. 根据校准的返回值res ，查看是哪种错误并进行判断。一共有一下几种错误类型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">enum &#123;</span><br><span class="line">&#x2F;* 00 *&#x2F; FAULT_NONE,</span><br><span class="line">&#x2F;* 01 *&#x2F; FAULT_TMOUT,</span><br><span class="line">&#x2F;* 02 *&#x2F; FAULT_CRASH,</span><br><span class="line">&#x2F;* 03 *&#x2F; FAULT_ERROR,</span><br><span class="line">&#x2F;* 04 *&#x2F; FAULT_NOINST,</span><br><span class="line">&#x2F;* 05 *&#x2F; FAULT_NOBITS &#125;;</span><br></pre></td></tr></table></figure>

<p>d. 打印一些错误信息，退出函数。</p>
<h3 id="★perform-dry-run-gt-calibrate-case函数"><a href="#★perform-dry-run-gt-calibrate-case函数" class="headerlink" title="★perform_dry_run -&gt; calibrate_case函数"></a>★perform_dry_run -&gt; calibrate_case函数</h3><p>校准一个新的测试用例。这是在处理输入目录时完成的，以便在早期就警告有问题的测试用例；当发现新的路径来检测变量行为等等。</p>
<p>这个函数是AFL的重点函数之一，在perform_dry_run，save_if_interesting，fuzz_one，pilot_fuzzing,core_fuzzing函数中均有调用。</p>
<p>步骤：</p>
<p>a. 进行一系列参数设置，包括当前阶段stage_cur，阶段名称stage_name，新比特new_bit等初始化设置。</p>
<p>b. 最后一个参数from_queue，判断是否是为队列中的||刚恢复fuzz 以此设置较长的时间延迟。testcase参数q-&gt;cal_failed++ 是否校准失败参数++</p>
<p>c. 判断是否已经启动forkserver ,调用函数init_forkserver()启动fork服务。</p>
<p>d. 拷贝trace_bits到first_trace,并获取开始时间start_us；</p>
<p>e. -loop- 该loop循环多次执行这个testcase，循环的次数 8次或者3次，取决于是否快速校准。对同一个初始testcase多次运行的意义可能是，觉得有些targetApp执行同一个testcase可能也会出现不同的路径（这是我的猜测）</p>
<p>f. static void write_to_testcase(void* mem, u32 len) 将修改后的数据写入文件进行测试。如果use_stdin被清除了，那么取消旧文件链接并创建一个新文件。否则，prog_in_fd将被缩短。将testcase写入到文件中去。该函数较简单，不做单独解释。</p>
<p>g. run_target作用是通知forkserver可以开始fork并且fuzz了。</p>
<p>h. cksum = hash32(trace_bits, MAP_SIZE, HASH_CONST)校验此次运行的trace_bits，检查是否出现新的情况。hash32函数较为简单，不多做分析。</p>
<p>i. 这段代码的主要意思是先用cksum也就是本次运行的出现trace_bits哈希和本次testcase q-&gt;exec_cksum对比。如果发现不同，则调用has_new_bits函数和我们的总表virgin_bits 对比。</p>
<p>j. 判断q-&gt;exec_cksum 是否为0，不为0那说明不是第一次执行。后面运行的时候如果，和前面第一次trace_bits结果不同，则需要多运行几次。这里把校准次数设为40…</p>
<p>k. -loop-end-</p>
<p>l. 接着收集一些关于这个测试用例性能的统计数据。比如执行时间延迟，校准错误？，bitmap大小等等。</p>
<p>m. update_bitmap_score(q) 对这个测试用例的每一个byte进行排序，用一个top_rate[]来维护它的最佳入口。维护完成之后，我们这个函数在</p>
<p>n. 如果这种情况没有从检测中得到new_bit，则告诉父程序。这是一个无关紧要的问题，但是需要提醒用户注意。</p>
<h3 id="★perform-dry-run-gt-calibrate-case-gt-init-forkserver"><a href="#★perform-dry-run-gt-calibrate-case-gt-init-forkserver" class="headerlink" title="★perform_dry_run -&gt; calibrate_case -&gt; init_forkserver"></a>★perform_dry_run -&gt; calibrate_case -&gt; init_forkserver</h3><h3 id="★-perform-dry-run-gt-calibrate-case-gt-run-target"><a href="#★-perform-dry-run-gt-calibrate-case-gt-run-target" class="headerlink" title="★ perform_dry_run -&gt; calibrate_case -&gt; run_target()"></a>★ perform_dry_run -&gt; calibrate_case -&gt; run_target()</h3><h3 id="★perform-dry-run-gt-calibrate-case-gt-has-new-bits"><a href="#★perform-dry-run-gt-calibrate-case-gt-has-new-bits" class="headerlink" title="★perform_dry_run -&gt; calibrate_case -&gt;   has_new_bits()"></a>★perform_dry_run -&gt; calibrate_case -&gt;   has_new_bits()</h3><h3 id="★perform-dry-run-gt-calibrate-case-gt-update-bitmap-score"><a href="#★perform-dry-run-gt-calibrate-case-gt-update-bitmap-score" class="headerlink" title="★perform_dry_run -&gt; calibrate_case -&gt;  update_bitmap_score()"></a>★perform_dry_run -&gt; calibrate_case -&gt;  update_bitmap_score()</h3><h3 id="★cull-queue"><a href="#★cull-queue" class="headerlink" title="★cull_queue()"></a>★cull_queue()</h3><p>static void cull_queue(void) 精简队列，上面第二个被讨论的机制是：检查toprated[]类目，以此前未见过的byte依次争夺优胜者，然后把他们标记为favored在下次开始跑之前。根据top_rated设置queue中的favored标志。在fuzz的过程中favored 条目将会给与更多的时间。</p>
<p>为了优化模糊工作，AFL使用快速算法定期重新评估队列，该算法选择一个较小的测试用例子集，该子集仍覆盖到目前为止所看到的每个元组，并且其特征使它们对Fuzzing特别有利。该算法通过为每个队列条目分配与其执行延迟和文件大小成正比的分数来工作;然后为每个tuples选择最低得分候选者。</p>
<p>cull_queue()遍历top_rated[]中的queue，然后提取出发现新的edge的entry，并标记为favored，使得在下次遍历queue时，这些entry能获得更多执行fuzz的机会。</p>
<p>这里本质上采用了贪婪算法，如果top_rated[i]存在，且对应temp_v[]中对应bit位还没抹去，即这一轮选出的queue还没覆盖bit_map[i]对应的边，则取出这个top_rated[i]。抹去temp_v中top_rated[i]能访问到的位。最后将这个top_rated[i]标记为favored,如果这个queue还没fuzzed，pending_favored++。</p>
<p>具体步骤：</p>
<p>a. 如果是dumb模式或者score_changed没有改变，也就是没有出现新的“favored”竞争者，那么函数直接返回，因为没有校准的意义。</p>
<p>b. 挨个遍历bitmap中的每个byte；核心代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">or (i &#x3D; 0; i &lt; MAP_SIZE; i++)</span><br><span class="line">   &#x2F;&#x2F;判断每个byte的top_rated是否存在 该byte对应的temp_v是否被置为1。</span><br><span class="line"> if (top_rated[i] &amp;&amp; (temp_v[i &gt;&gt; 3] &amp; (1 &lt;&lt; (i &amp; 7))))</span><br><span class="line"> &#123;</span><br><span class="line">   u32 j &#x3D; MAP_SIZE &gt;&gt; 3;</span><br><span class="line">&#x2F;* 从temp_v中，移除所有属于当前current-entry的byte，也就是这个testcase触发了多少path就给tempv标记上*&#x2F;</span><br><span class="line">   while (j--)</span><br><span class="line">     if (top_rated[i]-&gt;trace_mini[j])</span><br><span class="line">       temp_v[j] &amp;&#x3D; ~top_rated[i]-&gt;trace_mini[j];</span><br><span class="line">   top_rated[i]-&gt;favored &#x3D; 1;</span><br><span class="line">   queued_favored++;</span><br><span class="line">   if (top_rated[i]-&gt;fuzz_level &#x3D;&#x3D; 0 || !top_rated[i]-&gt;was_fuzzed) pending_favored++;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>这里需要结合update_bitmap_score()进行理解。update_bitmap_score在trim_case和calibrate_case中被调用，用来维护一个最小(favored)的测试用例集合(top_rated[i])。这里会比较执行时间*种子大小，如果当前用例更小，则会更新top_rated。结合以下事例更容易理解。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">tuple t0,t1,t2,t3,t4；seed s0,s1,s2 初始化temp_v&#x3D;[1,1,1,1,1]</span><br><span class="line">s1可覆盖t2,t3 | s2覆盖t0,t1,t4，并且top_rated[0]&#x3D;s2，top_rated[2]&#x3D;s1</span><br><span class="line">开始后判断temp_v[0]&#x3D;1，说明t0没有被访问</span><br><span class="line">top_rated[0]存在(s2) -&gt; 判断s2可以覆盖的范围 -&gt; trace_mini&#x3D;[1,1,0,0,1]</span><br><span class="line">更新temp_v&#x3D;[0,0,1,1,0]</span><br><span class="line">标记s2为favored</span><br><span class="line">继续判断temp_v[1]&#x3D;0，说明t1此时已经被访问过了，跳过</span><br><span class="line">继续判断temp_v[2]&#x3D;1，说明t2没有被访问</span><br><span class="line">top_rated[2]存在(s1) -&gt; 判断s1可以覆盖的范围 -&gt; trace_mini&#x3D;[0,0,1,1,0]</span><br><span class="line">更新temp_v&#x3D;[0,0,0,0,0]</span><br><span class="line">标记s1为favored</span><br><span class="line">此时所有tuple都被覆盖，favored为s1,s2</span><br></pre></td></tr></table></figure>

<p>c. 将queue中冗余的testcase进行标记 ，使用函数mark_as_redundant，位置/queue/.state/redundant_edges/中。</p>
<h3 id="sync-fuzzers"><a href="#sync-fuzzers" class="headerlink" title="sync_fuzzers()"></a>sync_fuzzers()</h3><p>读取其他fuzz的queue中的case文件,然后保存到自己的queue里</p>
<h3 id="★-fuzz-one"><a href="#★-fuzz-one" class="headerlink" title="★ fuzz_one()"></a>★ fuzz_one()</h3><p>static u8 fuzz_one_original(char** argv)从队列中取出当前testcase并模糊。这个函数太长了…如果fuzzed成功，返回0;如果跳过或退出，返回1。<br>步骤：</p>
<ul>
<li><p>根据是否有pending_favored和queue_cur的情况按照概率进行跳过；有pending_favored, 对于fuzz过的或者non-favored的以概率99%跳过；无pending_favored，95%跳过fuzzed&amp;non-favored，75%跳过not fuzzed&amp;non-favored，不跳过favored。</p>
</li>
<li><p>假如当前项有校准错误，并且校准错误次数小于3次，那么就用calibrate_case进行测试。</p>
</li>
<li><p>如果测试用例没有修剪过，那么调用函数[trim_case](★ trim_case())对测试用例进行修剪。</p>
</li>
<li><p>修剪完毕之后，使用<a href="#calculate_score()">calculate_score</a>对每个测试用例进行打分。函数详见3.6</p>
</li>
<li><p>如果该queue已经完成deterministic阶段，则直接跳到havoc阶段</p>
</li>
<li><p>deterministic阶段变异4个stage，变异过程中会多次调用函数common_fuzz_stuff函数见3.8，保存interesting 的种子：</p>
</li>
<li><p>bitflip，按位翻转，1变为0，0变为1</p>
</li>
<li><p>arithmetic，整数加/减算术运算</p>
</li>
<li><p>interest，把一些特殊内容替换到原文件中</p>
</li>
<li><p>dictionary，把自动生成或用户提供的token替换/插入到原文件中</p>
</li>
<li><p>havoc，中文意思是“大破坏”，此阶段会对原文件进行大量变异。</p>
</li>
<li><p>splice，中文意思是“绞接”，此阶段会将两个文件拼接起来得到一个新的文件。详细变异策略见3.7。</p>
</li>
<li><p>该 testcase完成。</p>
</li>
</ul>
<h3 id="★-trim-case"><a href="#★-trim-case" class="headerlink" title="★ trim_case()"></a>★ trim_case()</h3><p>static u8 trim_case(char** argv, struct queue_entry* q, u8* in_buf)在进行确定性检查时，修剪所有新的测试用例以节省周期。修剪器使用文件大小的1/16到1/1024之间的2次方增量，速度和效率的折中。</p>
<p>step：</p>
<ul>
<li>首先取testcase长度2的指数倍</li>
<li>第一个while循环，从文件大小1/16的步长开始，慢慢到文件大小的1/1024倍步长。</li>
<li>第二个while循环，嵌套在第一个内，从文件头开始按步长cut testcase，然后target_run();如果删除之后对文件执行路径没有影响那么就将这个删除保存至实际文件中。再删除之前会将trace_bits保存到起来。删除完成之后重新拷贝。如果不清楚看下面代码。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">static u8 trim_case(char** argv, struct queue_entry* q, u8* in_buf) &#123;</span><br><span class="line">....</span><br><span class="line">static u8 clean_trace[MAP_SIZE];</span><br><span class="line">u8 needs_write &#x3D; 0</span><br><span class="line">&#x2F;* 从文件长度1&#x2F;16开始最到最小1&#x2F;1024步长，设置移除文件的大小 *&#x2F;</span><br><span class="line">while (remove_len &gt;&#x3D; MAX(len_p2 &#x2F; TRIM_END_STEPS, TRIM_MIN_BYTES)) &#123;</span><br><span class="line">      &#x2F;*按选定的步长，移除，然后循环该文件*&#x2F;</span><br><span class="line">    while (remove_pos &lt; q-&gt;len) &#123;</span><br><span class="line">      &#x2F;&#x2F;删除</span><br><span class="line">         write_with_gap(in_buf, q-&gt;len, remove_pos, trim_avail);</span><br><span class="line">        &#x2F;&#x2F;执行</span><br><span class="line">         fault &#x3D; run_target(argv, exec_tmout);</span><br><span class="line">     &#x2F;* 检查trace_bit是否不一样 *&#x2F;</span><br><span class="line">         cksum &#x3D; hash32(trace_bits, MAP_SIZE, HASH_CONST);</span><br><span class="line">     &#x2F;* 如果删除对跟踪没有影响，则使其永久。作者表明可能可变路径会对此产生一些影响，不过没有大碍*&#x2F;</span><br><span class="line">         if (cksum &#x3D;&#x3D; q-&gt;exec_cksum) &#123;</span><br><span class="line">          memmove(in_buf + remove_pos, in_buf + remove_pos + trim_avail, move_tail);</span><br><span class="line">       &#x2F;* 保存之前的trace_bits，因为执行如果改变了trace_bits*&#x2F;</span><br><span class="line">           if (!needs_write) &#123;</span><br><span class="line">         memcpy(clean_trace, trace_bits, MAP_SIZE);&#125;</span><br><span class="line">     &#125; else remove_pos +&#x3D; remove_len;</span><br><span class="line">   &#125;</span><br><span class="line">   remove_len &gt;&gt;&#x3D; 1; &#x2F;&#x2F;增加步长</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>文件大小对模糊性能有很大影响，这是因为大文件使目标二进制文件变得更慢，并且因为它们减少了突变将触及重要的格式控制结构而不是冗余数据块的可能性。这在perf_tips.txt中有更详细的讨论。</p>
<p>用户可能会提供低质量的起始语料库，某些类型的突变可能会产生迭代地增加生成文件的大小的效果，因此应对这一趋势是很重要的。</p>
<p>幸运的是，插装反馈提供了一种简单的方法来自动删除输入文件，同时确保对文件的更改不会对执行路径产生影响。</p>
<p>在afl-fuzz中内置的修边器试图按可变长度和stepover顺序删除数据块;任何不影响跟踪映射校验和的删除都被提交到磁盘。修剪器的设计并不是特别彻底;相反，它试图在精度和在进程上花费的execve（）调用的数量之间取得平衡，选择块大小和stepover来匹配。每个文件的平均增益大约在5%到20%之间。</p>
<p>独立的afl-tmin工具使用了更详尽的迭代算法，并尝试在修剪过的文件上执行字母标准化。afl-tmin的操作如下。</p>
<p>首先，工具自动选择操作模式。如果初始输入崩溃了目标二进制文件，afl-tmin将以非插装模式运行，只需保留任何能产生更简单文件但仍然会使目标崩溃的调整。如果目标是非崩溃的，那么这个工具使用一个插装的模式，并且只保留那些产生完全相同的执行路径的微调。</p>
<h3 id="calculate-score"><a href="#calculate-score" class="headerlink" title="calculate_score()"></a>calculate_score()</h3><h2 id="afl-as-c"><a href="#afl-as-c" class="headerlink" title="afl-as.c"></a>afl-as.c</h2></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">tianmai</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2023/03/06/afl%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">http://example.com/2023/03/06/afl%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">pwnpwn小菜鸡</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/03/09/afl%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%901/"><img class="prev-cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">afl分析</div></div></a></div><div class="next-post pull-right"><a href="/2023/01/25/io/"><img class="next-cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">io之global_max_fast+fsop</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">tianmai</div><div class="author-info__description">pwn rop 格式化</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">35</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">1</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#afl-gcc-c%E5%88%86%E6%9E%90"><span class="toc-number">1.</span> <span class="toc-text">afl-gcc.c分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#find-as"><span class="toc-number">1.1.</span> <span class="toc-text">find_as</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#edit-params"><span class="toc-number">1.2.</span> <span class="toc-text">edit_params</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#execvp"><span class="toc-number">1.3.</span> <span class="toc-text">execvp</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.4.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#afl-fuzz-c"><span class="toc-number">2.</span> <span class="toc-text">afl-fuzz.c</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#while-opt-getopt-argc-argv-%E2%80%9C-i-o-f-m-t-T-dnCB-S-M-x-Q%E2%80%9D-gt-0"><span class="toc-number">2.1.</span> <span class="toc-text">while ((opt &#x3D; getopt(argc, argv, “+i:o:f:m:t:T:dnCB:S:M:x:Q”)) &gt; 0)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#usage-argv-0"><span class="toc-number">2.2.</span> <span class="toc-text">usage(argv[0])</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#setup-signal-handlers"><span class="toc-number">2.3.</span> <span class="toc-text">setup_signal_handlers();</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#check-asan-opts"><span class="toc-number">2.4.</span> <span class="toc-text">check_asan_opts();</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fix-up-sync"><span class="toc-number">2.5.</span> <span class="toc-text">fix_up_sync</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E5%A0%86%E6%A3%80%E6%9F%A5%E7%AD%89"><span class="toc-number">2.6.</span> <span class="toc-text">一堆检查等</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#save-cmdline-argc-argv"><span class="toc-number">2.7.</span> <span class="toc-text">save_cmdline(argc, argv);</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fix-up-banner-argv-optind"><span class="toc-number">2.8.</span> <span class="toc-text">fix_up_banner(argv[optind]);</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#check-if-tty"><span class="toc-number">2.9.</span> <span class="toc-text">check_if_tty();</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cpu%E6%A3%80%E6%9F%A5"><span class="toc-number">2.10.</span> <span class="toc-text">cpu检查</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#setup-post"><span class="toc-number">2.11.</span> <span class="toc-text">setup_post();</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#setup-shm"><span class="toc-number">2.12.</span> <span class="toc-text">setup_shm();</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#init-count-class16"><span class="toc-number">2.13.</span> <span class="toc-text">init_count_class16();</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#setup-dirs-fds"><span class="toc-number">2.14.</span> <span class="toc-text">setup_dirs_fds();</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#read-testcases"><span class="toc-number">2.15.</span> <span class="toc-text">read_testcases();</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#add-to-queue-fn-st-st-size-passed-det"><span class="toc-number">2.16.</span> <span class="toc-text">add_to_queue(fn, st.st_size, passed_det);</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#load-auto"><span class="toc-number">2.17.</span> <span class="toc-text">load_auto();</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pivot-inputs"><span class="toc-number">2.18.</span> <span class="toc-text">pivot_inputs();</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#load-extras"><span class="toc-number">2.19.</span> <span class="toc-text">load_extras</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#find-timeout"><span class="toc-number">2.20.</span> <span class="toc-text">find_timeout</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#detect-file-args"><span class="toc-number">2.21.</span> <span class="toc-text">detect_file_args</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#setup-stdio-file"><span class="toc-number">2.22.</span> <span class="toc-text">setup_stdio_file</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#check-binary-argv-optind"><span class="toc-number">2.23.</span> <span class="toc-text">check_binary(argv[optind]);</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A3%80%E6%9F%A5"><span class="toc-number">2.24.</span> <span class="toc-text">检查</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%98%85%E5%BC%80%E5%A7%8B%E7%AC%AC%E4%B8%80%E9%81%8Dfuzz-%E2%80%94%E2%80%94-perform-dry-run"><span class="toc-number">2.25.</span> <span class="toc-text">★开始第一遍fuzz  —— perform_dry_run</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%98%85perform-dry-run-gt-calibrate-case%E5%87%BD%E6%95%B0"><span class="toc-number">2.26.</span> <span class="toc-text">★perform_dry_run -&gt; calibrate_case函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%98%85perform-dry-run-gt-calibrate-case-gt-init-forkserver"><span class="toc-number">2.27.</span> <span class="toc-text">★perform_dry_run -&gt; calibrate_case -&gt; init_forkserver</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%98%85-perform-dry-run-gt-calibrate-case-gt-run-target"><span class="toc-number">2.28.</span> <span class="toc-text">★ perform_dry_run -&gt; calibrate_case -&gt; run_target()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%98%85perform-dry-run-gt-calibrate-case-gt-has-new-bits"><span class="toc-number">2.29.</span> <span class="toc-text">★perform_dry_run -&gt; calibrate_case -&gt;   has_new_bits()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%98%85perform-dry-run-gt-calibrate-case-gt-update-bitmap-score"><span class="toc-number">2.30.</span> <span class="toc-text">★perform_dry_run -&gt; calibrate_case -&gt;  update_bitmap_score()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%98%85cull-queue"><span class="toc-number">2.31.</span> <span class="toc-text">★cull_queue()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sync-fuzzers"><span class="toc-number">2.32.</span> <span class="toc-text">sync_fuzzers()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%98%85-fuzz-one"><span class="toc-number">2.33.</span> <span class="toc-text">★ fuzz_one()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%98%85-trim-case"><span class="toc-number">2.34.</span> <span class="toc-text">★ trim_case()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#calculate-score"><span class="toc-number">2.35.</span> <span class="toc-text">calculate_score()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#afl-as-c"><span class="toc-number">3.</span> <span class="toc-text">afl-as.c</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/03/09/afl%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%901/" title="afl分析"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="afl分析"/></a><div class="content"><a class="title" href="/2023/03/09/afl%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%901/" title="afl分析">afl分析</a><time datetime="2023-03-09T10:02:48.661Z" title="发表于 2023-03-09 18:02:48">2023-03-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/03/06/afl%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" title="afl源码分析"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="afl源码分析"/></a><div class="content"><a class="title" href="/2023/03/06/afl%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" title="afl源码分析">afl源码分析</a><time datetime="2023-03-06T07:48:28.321Z" title="发表于 2023-03-06 15:48:28">2023-03-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/01/25/io/" title="io之global_max_fast+fsop"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="io之global_max_fast+fsop"/></a><div class="content"><a class="title" href="/2023/01/25/io/" title="io之global_max_fast+fsop">io之global_max_fast+fsop</a><time datetime="2023-01-25T11:15:42.690Z" title="发表于 2023-01-25 19:15:42">2023-01-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/04/11/%E6%89%80%E6%9C%89%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/" title="all刷题记录"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="all刷题记录"/></a><div class="content"><a class="title" href="/2022/04/11/%E6%89%80%E6%9C%89%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/" title="all刷题记录">all刷题记录</a><time datetime="2022-04-11T11:23:27.445Z" title="发表于 2022-04-11 19:23:27">2022-04-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/04/05/huose_of_storm+setcontest/" title="house of storm加setcontest利用"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="house of storm加setcontest利用"/></a><div class="content"><a class="title" href="/2022/04/05/huose_of_storm+setcontest/" title="house of storm加setcontest利用">house of storm加setcontest利用</a><time datetime="2022-04-05T08:43:31.449Z" title="发表于 2022-04-05 16:43:31">2022-04-05</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By tianmai</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>